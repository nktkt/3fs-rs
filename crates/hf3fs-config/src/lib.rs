extern crate self as hf3fs_config;

mod manager;

pub use hf3fs_config_derive::Config;

use thiserror::Error;

#[derive(Debug, Error)]
pub enum ConfigError {
    #[error("type mismatch for field '{field}': expected {expected}")]
    TypeMismatch { field: String, expected: String },
    #[error("field '{field}' value {value} out of range (min: {min:?}, max: {max:?})")]
    OutOfRange {
        field: String,
        value: String,
        min: Option<String>,
        max: Option<String>,
    },
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("TOML parse error: {0}")]
    TomlParse(#[from] toml::de::Error),
    #[error("missing required field: {0}")]
    MissingField(String),
}

/// Core trait for configuration types.
/// Generated by #[derive(Config)] from hf3fs-config-derive.
pub trait Config: Sized + Default + Send + Sync + 'static {
    fn from_toml(value: &toml::Value) -> Result<Self, ConfigError>;
    fn hot_update(&mut self, other: &Self);
    fn render(&self) -> String;
    fn validate(&self) -> Result<(), ConfigError>;
}

pub use manager::ConfigManager;

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write as _;

    #[derive(Clone, Debug, Config)]
    struct InnerConfig {
        #[config(default = 100, min = 1, max = 1000)]
        buffer_size: u32,
        #[config(default = true, hot_updated)]
        enabled: bool,
    }

    #[derive(Clone, Debug, Config)]
    struct TestConfig {
        #[config(default = 8080, min = 1, max = 65535)]
        port: u16,
        #[config(default = "localhost")]
        host: String,
        #[config(default = 4, min = 1, max = 64, hot_updated)]
        workers: i32,
        #[config(section)]
        inner: InnerConfig,
    }

    #[test]
    fn test_default() {
        let cfg = TestConfig::default();
        assert_eq!(cfg.port, 8080);
        assert_eq!(cfg.host, "localhost");
        assert_eq!(cfg.workers, 4);
        assert_eq!(cfg.inner.buffer_size, 100);
        assert!(cfg.inner.enabled);
    }

    #[test]
    fn test_from_toml() {
        let toml_str = r#"
            port = 9090
            host = "example.com"
            workers = 8

            [inner]
            buffer_size = 512
            enabled = false
        "#;
        let value: toml::Value = toml_str.parse().unwrap();
        let cfg = TestConfig::from_toml(&value).unwrap();
        assert_eq!(cfg.port, 9090);
        assert_eq!(cfg.host, "example.com");
        assert_eq!(cfg.workers, 8);
        assert_eq!(cfg.inner.buffer_size, 512);
        assert!(!cfg.inner.enabled);
    }

    #[test]
    fn test_from_toml_defaults() {
        let toml_str = r#"
            port = 3000
        "#;
        let value: toml::Value = toml_str.parse().unwrap();
        let cfg = TestConfig::from_toml(&value).unwrap();
        assert_eq!(cfg.port, 3000);
        assert_eq!(cfg.host, "localhost");
        assert_eq!(cfg.workers, 4);
        assert_eq!(cfg.inner.buffer_size, 100);
        assert!(cfg.inner.enabled);
    }

    #[test]
    fn test_validate_ok() {
        let cfg = TestConfig::default();
        assert!(cfg.validate().is_ok());
    }

    #[test]
    fn test_validate_out_of_range() {
        let toml_str = r#"
            port = 0
        "#;
        let value: toml::Value = toml_str.parse().unwrap();
        let cfg = TestConfig::from_toml(&value).unwrap();
        let err = cfg.validate().unwrap_err();
        let msg = err.to_string();
        assert!(msg.contains("out of range"), "got: {msg}");
        assert!(msg.contains("port"), "got: {msg}");
    }

    #[test]
    fn test_hot_update() {
        let mut cfg = TestConfig::default();
        assert_eq!(cfg.workers, 4);
        assert!(cfg.inner.enabled);

        let toml_str = r#"
            port = 9999
            workers = 16
            [inner]
            buffer_size = 200
            enabled = false
        "#;
        let value: toml::Value = toml_str.parse().unwrap();
        let new_cfg = TestConfig::from_toml(&value).unwrap();

        cfg.hot_update(&new_cfg);

        // hot_updated fields should change
        assert_eq!(cfg.workers, 16);
        assert!(!cfg.inner.enabled);

        // non-hot_updated fields should NOT change
        assert_eq!(cfg.port, 8080);
        assert_eq!(cfg.host, "localhost");
        assert_eq!(cfg.inner.buffer_size, 100);
    }

    #[test]
    fn test_render() {
        let cfg = TestConfig::default();
        let rendered = cfg.render();
        assert!(rendered.contains("port = 8080"), "got: {rendered}");
        assert!(rendered.contains("host = \"localhost\""), "got: {rendered}");
        assert!(rendered.contains("workers = 4"), "got: {rendered}");
        assert!(rendered.contains("buffer_size = 100"), "got: {rendered}");
    }

    #[test]
    fn test_config_manager_new_and_get() {
        let cfg = TestConfig::default();
        let mgr = ConfigManager::new(cfg);
        let loaded = mgr.get();
        assert_eq!(loaded.port, 8080);
        assert_eq!(loaded.host, "localhost");
    }

    #[test]
    fn test_config_manager_update() {
        let mgr = ConfigManager::new(TestConfig::default());
        let mut new_cfg = TestConfig::default();
        new_cfg.port = 3000;
        new_cfg.host = "0.0.0.0".into();
        mgr.update(new_cfg).unwrap();

        let loaded = mgr.get();
        assert_eq!(loaded.port, 3000);
        assert_eq!(loaded.host, "0.0.0.0");
    }

    #[test]
    fn test_config_manager_update_validates() {
        let mgr = ConfigManager::new(TestConfig::default());
        let toml_str = r#"
            port = 0
        "#;
        let value: toml::Value = toml_str.parse().unwrap();
        let bad_cfg = TestConfig::from_toml(&value).unwrap();
        assert!(mgr.update(bad_cfg).is_err());

        // Original config should be unchanged
        let loaded = mgr.get();
        assert_eq!(loaded.port, 8080);
    }

    #[test]
    fn test_config_manager_snapshot() {
        let mgr = ConfigManager::new(TestConfig::default());
        let snap = mgr.snapshot();
        assert_eq!(snap.port, 8080);
    }

    #[test]
    fn test_config_manager_load_and_reload() {
        let dir = std::env::temp_dir().join("hf3fs_config_test");
        std::fs::create_dir_all(&dir).unwrap();
        let path = dir.join("test.toml");

        // Write initial config
        {
            let mut f = std::fs::File::create(&path).unwrap();
            writeln!(f, "port = 9090\nworkers = 2\n[inner]\nbuffer_size = 50\nenabled = true")
                .unwrap();
        }

        let mgr = ConfigManager::<TestConfig>::load(&path).unwrap();
        assert_eq!(mgr.get().port, 9090);
        assert_eq!(mgr.get().workers, 2);

        // Write updated config and reload
        {
            let mut f = std::fs::File::create(&path).unwrap();
            writeln!(
                f,
                "port = 7070\nworkers = 32\n[inner]\nbuffer_size = 999\nenabled = false"
            )
            .unwrap();
        }

        mgr.reload().unwrap();

        // hot_updated field (workers) should update
        assert_eq!(mgr.get().workers, 32);
        // hot_updated field (inner.enabled) should update
        assert!(!mgr.get().inner.enabled);
        // non-hot_updated field (port) should stay at original
        assert_eq!(mgr.get().port, 9090);
        // non-hot_updated field (inner.buffer_size) should stay
        assert_eq!(mgr.get().inner.buffer_size, 50);

        // Clean up
        let _ = std::fs::remove_dir_all(&dir);
    }

    #[test]
    fn test_type_mismatch_error() {
        let toml_str = r#"
            port = "not_a_number"
        "#;
        let value: toml::Value = toml_str.parse().unwrap();
        let err = TestConfig::from_toml(&value).unwrap_err();
        let msg = err.to_string();
        assert!(msg.contains("type mismatch"), "got: {msg}");
        assert!(msg.contains("port"), "got: {msg}");
    }
}
